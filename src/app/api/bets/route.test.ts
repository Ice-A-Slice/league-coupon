import { POST } from './route'; // Import the handler to test
import { createServerClient } from '@supabase/ssr';
import { cookies } from 'next/headers';
import { NextResponse } from 'next/server';

// --- Mocks ---

// Mock next/headers
const mockCookieStore = {
  get: jest.fn(),
  set: jest.fn(),
  delete: jest.fn(),
};
jest.mock('next/headers', () => ({
  cookies: jest.fn(() => mockCookieStore), // Return our mock store
}));

// Mock @supabase/ssr - REFINE MOCKS for clarity
const mockSupabaseGetUser = jest.fn();
const mockSupabaseUpsert = jest.fn();

// Consolidate chaining mocks for fixture lookups (OLD - NO LONGER USED FOR VALIDATION)
// const mockMaybeSingle = jest.fn(); 
// const mockLimit = jest.fn(() => ({ maybeSingle: mockMaybeSingle }));
// const mockOrder = jest.fn(() => ({ limit: mockLimit }));
// const mockInFixtures = jest.fn(() => ({ order: mockOrder })); // Renamed for clarity
// const mockSelectFixtures = jest.fn(() => ({ in: mockInFixtures })); // Renamed for clarity

// --- NEW Mocks for Betting Round Validation Logic ---
const mockInRoundFixtures = jest.fn();
const mockSelectRoundFixtures = jest.fn(() => ({ in: mockInRoundFixtures }));

const mockSingleRound = jest.fn();
const mockEqRound = jest.fn(() => ({ single: mockSingleRound }));
const mockSelectRound = jest.fn(() => ({ eq: mockEqRound }));
// --- End NEW Mocks ---

const mockFrom = jest.fn(); // Keep the main mockFrom

const mockAuth = {
  getUser: mockSupabaseGetUser,
};
const mockSupabaseClient = {
  auth: mockAuth,
  from: mockFrom,
};
jest.mock('@supabase/ssr', () => ({
  createServerClient: jest.fn(() => mockSupabaseClient),
}));

// Mock next/server
const mockNextResponseJson = jest.fn();
jest.mock('next/server', () => ({
  NextResponse: {
    json: jest.fn((body, init) => {
      mockNextResponseJson(body, init); // Track calls
      // Return a simple object simulating the response structure for inspection
      return { status: init?.status ?? 200, body }; 
    }),
  },
}));

// --- Test Suite ---
describe('POST /api/bets', () => {
  
  beforeEach(() => {
    // Reset all mocks before each test
    jest.clearAllMocks();
    mockCookieStore.get.mockClear();
    mockCookieStore.set.mockClear();
    mockCookieStore.delete.mockClear();
    mockSupabaseGetUser.mockClear();
    mockSupabaseUpsert.mockClear();
    // Reset NEW chaining mocks
    mockSelectRoundFixtures.mockClear();
    mockInRoundFixtures.mockClear();
    mockSelectRound.mockClear();
    mockEqRound.mockClear();
    mockSingleRound.mockClear();
    // Reset OLD fixture mocks (still needed for user_bets)
    // mockSelectFixtures.mockClear(); 
    // mockInFixtures.mockClear(); 
    // mockOrder.mockClear(); 
    // mockLimit.mockClear(); 
    // mockMaybeSingle.mockClear(); 
    mockFrom.mockClear();
    mockNextResponseJson.mockClear();
    (cookies as jest.Mock).mockClear();
    (createServerClient as jest.Mock).mockClear();
    (NextResponse.json as jest.Mock).mockClear();

    // Default mock implementation for .from()
    mockFrom.mockImplementation((tableName: string) => {
      // --- Updated mockFrom --- 
      if (tableName === 'betting_round_fixtures') {
        return { select: mockSelectRoundFixtures }; 
      } else if (tableName === 'betting_rounds') {
        return { select: mockSelectRound };
      } else if (tableName === 'user_bets') {
        return { upsert: mockSupabaseUpsert };
      } else if (tableName === 'fixtures') { 
          // Keep a basic mock for fixtures in case it's used elsewhere, 
          // but it shouldn't be called for validation in the main flow now.
          console.warn('Unexpected call to from("fixtures") during bet submission test');
          return { select: jest.fn(() => ({ in: jest.fn(() => ({ order: jest.fn(() => ({ limit: jest.fn(() => ({ maybeSingle: jest.fn() })) })) })) })) };
      }
      // Default fallback if needed
      console.warn(`Unmocked table called in test: ${tableName}`);
      return { select: jest.fn(), upsert: jest.fn() };
    });
  });

  // Test case 1: Successful submission
  it('should return 200 OK on successful bet submission for an open round', async () => {
    // Arrange
    const mockUserId = 'test-user-123';
    const mockBettingRoundId = 1; // Use the ID generated by the service
    const mockFixtureId1 = 673;
    const mockFixtureId2 = 675;
    const requestBody = [
      { fixture_id: mockFixtureId1, prediction: '1' },
      { fixture_id: mockFixtureId2, prediction: 'X' },
    ];
    const submittedFixtureIds = [mockFixtureId1, mockFixtureId2];
    const request = new Request('http://localhost/api/bets', {
      method: 'POST',
      body: JSON.stringify(requestBody),
      headers: { 'Content-Type': 'application/json' },
    });
    const futureKickoff = new Date();
    futureKickoff.setDate(futureKickoff.getDate() + 1); 

    mockSupabaseGetUser.mockResolvedValue({ data: { user: { id: mockUserId } }, error: null });
    // Mock the NEW validation flow:
    // 1. Mock betting_round_fixtures lookup
    mockInRoundFixtures.mockResolvedValue({ 
        data: [ { betting_round_id: mockBettingRoundId }, { betting_round_id: mockBettingRoundId }], 
        error: null 
    });
    // 2. Mock betting_rounds lookup
    mockSingleRound.mockResolvedValue({ 
        data: { status: 'open', earliest_fixture_kickoff: futureKickoff.toISOString() }, 
        error: null 
    });
    // Mock successful upsert
    mockSupabaseUpsert.mockResolvedValue({ error: null });

    // Act
    await POST(request);

    // Assert
    expect(mockSupabaseGetUser).toHaveBeenCalledTimes(1);
    // Check NEW validation calls
    expect(mockFrom).toHaveBeenCalledWith('betting_round_fixtures');
    expect(mockSelectRoundFixtures).toHaveBeenCalledWith('betting_round_id');
    expect(mockInRoundFixtures).toHaveBeenCalledWith('fixture_id', submittedFixtureIds);
    
    expect(mockFrom).toHaveBeenCalledWith('betting_rounds');
    expect(mockSelectRound).toHaveBeenCalledWith('status, earliest_fixture_kickoff');
    expect(mockEqRound).toHaveBeenCalledWith('id', mockBettingRoundId);
    expect(mockSingleRound).toHaveBeenCalledTimes(1);

    // Check TOTAL calls to mockFrom (round_fixtures + rounds + user_bets)
    expect(mockFrom).toHaveBeenCalledTimes(3); 
    // Check upsert call
    expect(mockFrom).toHaveBeenCalledWith('user_bets');
    expect(mockSupabaseUpsert).toHaveBeenCalledTimes(1);
    const upsertArg = mockSupabaseUpsert.mock.calls[0][0];
    expect(upsertArg).toHaveLength(requestBody.length);
    expect(upsertArg[0]).toMatchObject({
        user_id: mockUserId,
        fixture_id: mockFixtureId1,
        prediction: '1',
        betting_round_id: mockBettingRoundId, // Check for correct column name
    });
     expect(upsertArg[1]).toMatchObject({
        user_id: mockUserId,
        fixture_id: mockFixtureId2,
        prediction: 'X',
        betting_round_id: mockBettingRoundId, // Check for correct column name
    });
    expect(mockSupabaseUpsert.mock.calls[0][1]).toEqual({ onConflict: 'user_id, fixture_id' });
    // Check final response
    expect(mockNextResponseJson).toHaveBeenCalledTimes(1);
    expect(mockNextResponseJson).toHaveBeenCalledWith({ message: 'Bets submitted successfully!' }, { status: 200 });
  });

  // Test case 2: Unauthorized access
  it('should return 401 Unauthorized if user is not authenticated', async () => {
    // Arrange
    const requestBody = [{ fixture_id: 1, prediction: '1' }]; // Example body
    const request = new Request('http://localhost/api/bets', {
      method: 'POST',
      body: JSON.stringify(requestBody),
      headers: { 'Content-Type': 'application/json' },
    });

    // Mock getUser to return no user
    mockSupabaseGetUser.mockResolvedValue({ data: { user: null }, error: null });

    // Act
    await POST(request);

    // Assert
    expect(mockSupabaseGetUser).toHaveBeenCalledTimes(1);
    expect(mockFrom).not.toHaveBeenCalled(); // Should not attempt DB operations
    expect(mockNextResponseJson).toHaveBeenCalledTimes(1);
    expect(mockNextResponseJson).toHaveBeenCalledWith({ error: 'Unauthorized' }, { status: 401 });
  });

  // Test case 3: Invalid request body (not array)
  it('should return 400 Bad Request if request body is not a valid array', async () => {
      // Arrange
      const request = new Request('http://localhost/api/bets', {
        method: 'POST',
        body: JSON.stringify({ fixture_id: 1, prediction: '1' }), // Send an object, not an array
        headers: { 'Content-Type': 'application/json' },
      });
      // Mock getUser to return a valid user (needed to get past auth check)
      mockSupabaseGetUser.mockResolvedValue({ data: { user: { id: 'test-user' } }, error: null });

      // Act
      await POST(request);

      // Assert
      expect(mockSupabaseGetUser).toHaveBeenCalledTimes(1);
      expect(mockFrom).not.toHaveBeenCalled(); // Should fail before DB interaction
      expect(mockNextResponseJson).toHaveBeenCalledTimes(1);
      expect(mockNextResponseJson).toHaveBeenCalledWith({ error: 'Invalid request body. Expected a non-empty array of bets.' }, { status: 400 });
  });
  
  // Test case 4: Invalid request body (empty array)
  it('should return 400 Bad Request if request body is an empty array', async () => {
       // Arrange
      const request = new Request('http://localhost/api/bets', {
        method: 'POST',
        body: JSON.stringify([]), // Send an empty array
        headers: { 'Content-Type': 'application/json' },
      });
      mockSupabaseGetUser.mockResolvedValue({ data: { user: { id: 'test-user' } }, error: null });

      // Act
      await POST(request);

      // Assert
      expect(mockSupabaseGetUser).toHaveBeenCalledTimes(1);
      expect(mockFrom).not.toHaveBeenCalled(); 
      expect(mockNextResponseJson).toHaveBeenCalledTimes(1);
      expect(mockNextResponseJson).toHaveBeenCalledWith({ error: 'Invalid request body. Expected a non-empty array of bets.' }, { status: 400 });
  });

  // Test case 5: Round has already started (locked)
  it('should return 403 Forbidden if the betting deadline has passed', async () => {
      // Arrange
      const mockUserId = 'test-user-403';
      const mockBettingRoundId = 1; // Consistent ID
      const mockFixtureId = 700;
      const requestBody = [{ fixture_id: mockFixtureId, prediction: '2' }];
      const submittedFixtureIds = [mockFixtureId];
      const request = new Request('http://localhost/api/bets', {
        method: 'POST',
        body: JSON.stringify(requestBody),
        headers: { 'Content-Type': 'application/json' },
      });
      const pastKickoff = new Date();
      pastKickoff.setDate(pastKickoff.getDate() - 1); // Kickoff was yesterday
      
      mockSupabaseGetUser.mockResolvedValue({ data: { user: { id: mockUserId } }, error: null });
      // Mock the NEW validation flow:
      // 1. Mock betting_round_fixtures lookup (success)
      mockInRoundFixtures.mockResolvedValue({ 
          data: [ { betting_round_id: mockBettingRoundId }], 
          error: null 
      });
      // 2. Mock betting_rounds lookup to return a past kickoff
      mockSingleRound.mockResolvedValue({ 
          data: { status: 'open', earliest_fixture_kickoff: pastKickoff.toISOString() }, 
          error: null 
      });

      // Act
      await POST(request);

      // Assert
      expect(mockSupabaseGetUser).toHaveBeenCalledTimes(1);
      // Check NEW validation calls were made correctly
      expect(mockFrom).toHaveBeenCalledWith('betting_round_fixtures');
      expect(mockSelectRoundFixtures).toHaveBeenCalledWith('betting_round_id');
      expect(mockInRoundFixtures).toHaveBeenCalledWith('fixture_id', submittedFixtureIds);
      
      expect(mockFrom).toHaveBeenCalledWith('betting_rounds');
      expect(mockSelectRound).toHaveBeenCalledWith('status, earliest_fixture_kickoff');
      expect(mockEqRound).toHaveBeenCalledWith('id', mockBettingRoundId); // Use consistent ID
      expect(mockSingleRound).toHaveBeenCalledTimes(1);

      // Ensure upsert was NOT called
      expect(mockSupabaseUpsert).not.toHaveBeenCalled(); 
      // Check TOTAL calls to mockFrom (round_fixtures + rounds)
      expect(mockFrom).toHaveBeenCalledTimes(2); 
      // Check final response
      expect(mockNextResponseJson).toHaveBeenCalledTimes(1);
      expect(mockNextResponseJson).toHaveBeenCalledWith({ error: 'Cannot submit bets, the betting deadline has passed.' }, { status: 403 });
  });

  // Test case 6: Invalid fixture ID during locking check
  it('should return 400 Bad Request if submitted fixtures are not in a betting round', async () => {
      // Arrange
      const mockUserId = 'test-user-404';
      const invalidFixtureId = 9999;
      const requestBody = [{ fixture_id: invalidFixtureId, prediction: '1' }];
      const submittedFixtureIds = [invalidFixtureId];
       const request = new Request('http://localhost/api/bets', {
        method: 'POST',
        body: JSON.stringify(requestBody),
        headers: { 'Content-Type': 'application/json' },
      });
      mockSupabaseGetUser.mockResolvedValue({ data: { user: { id: mockUserId } }, error: null });
      // Mock betting_round_fixtures lookup to return NO results
      mockInRoundFixtures.mockResolvedValue({ data: [], error: null }); 

      // Act
      await POST(request);

      // Assert
      expect(mockSupabaseGetUser).toHaveBeenCalledTimes(1);
      // Check that only the first part of validation was called
      expect(mockFrom).toHaveBeenCalledWith('betting_round_fixtures');
      expect(mockSelectRoundFixtures).toHaveBeenCalledWith('betting_round_id');
      expect(mockInRoundFixtures).toHaveBeenCalledWith('fixture_id', submittedFixtureIds);
      // Ensure other DB calls were NOT made
      expect(mockFrom).toHaveBeenCalledTimes(1); 
      expect(mockSelectRound).not.toHaveBeenCalled();
      expect(mockSupabaseUpsert).not.toHaveBeenCalled(); 
      // Check final response
      expect(mockNextResponseJson).toHaveBeenCalledTimes(1);
      expect(mockNextResponseJson).toHaveBeenCalledWith({ error: 'Invalid submission: Fixtures do not belong to a betting round.' }, { status: 400 });
  });
  
  // Test case 7: Database error during upsert
  it('should return 500 Internal Server Error if database upsert fails', async () => {
      // Arrange
      const mockUserId = 'test-user-500-upsert';
      const mockBettingRoundId = 1; // Consistent ID
      const mockFixtureId = 710;
      const requestBody = [{ fixture_id: mockFixtureId, prediction: 'X' }];
      const submittedFixtureIds = [mockFixtureId];
      const request = new Request('http://localhost/api/bets', {
        method: 'POST',
        body: JSON.stringify(requestBody),
        headers: { 'Content-Type': 'application/json' },
      });
      const futureKickoff = new Date();
      futureKickoff.setDate(futureKickoff.getDate() + 1); 
      
      mockSupabaseGetUser.mockResolvedValue({ data: { user: { id: mockUserId } }, error: null });
      // Mock NEW validation flow to succeed
      mockInRoundFixtures.mockResolvedValue({ data: [{ betting_round_id: mockBettingRoundId }], error: null });
      mockSingleRound.mockResolvedValue({ data: { status: 'open', earliest_fixture_kickoff: futureKickoff.toISOString() }, error: null });
      // Mock upsert to fail
      const upsertDbError = { message: 'Database unavailable', code: '50000' };
      mockSupabaseUpsert.mockResolvedValue({ error: upsertDbError });

      // Act
      await POST(request);

      // Assert
      expect(mockSupabaseGetUser).toHaveBeenCalledTimes(1);
      // Check validation calls were made
      expect(mockFrom).toHaveBeenCalledWith('betting_round_fixtures');
      expect(mockFrom).toHaveBeenCalledWith('betting_rounds');
      // Check upsert call was made
      expect(mockFrom).toHaveBeenCalledWith('user_bets');
      expect(mockSupabaseUpsert).toHaveBeenCalledTimes(1); // Upsert was attempted
      // Check TOTAL calls to mockFrom (round_fixtures + rounds + user_bets)
      expect(mockFrom).toHaveBeenCalledTimes(3);
      // Check final response
      expect(mockNextResponseJson).toHaveBeenCalledTimes(1);
      expect(mockNextResponseJson).toHaveBeenCalledWith({ error: 'Failed to save bets to database.' }, { status: 500 });
  });

  // Test case 8: Database error during locking check (kickoff fetch)
  it('should return 500 Internal Server Error if fetching betting round details fails', async () => {
      // Arrange
       const mockUserId = 'test-user-500-kickoff';
       const mockBettingRoundId = 1; // Consistent ID
      const mockFixtureId = 720;
      const requestBody = [{ fixture_id: mockFixtureId, prediction: '1' }];
      const submittedFixtureIds = [mockFixtureId];
      const request = new Request('http://localhost/api/bets', {
        method: 'POST',
        body: JSON.stringify(requestBody),
        headers: { 'Content-Type': 'application/json' },
      });
      const roundDbError = { message: 'Connection error', code: '50001' };

      mockSupabaseGetUser.mockResolvedValue({ data: { user: { id: mockUserId } }, error: null });
      // Mock betting_round_fixtures lookup to succeed
      mockInRoundFixtures.mockResolvedValue({ data: [{ betting_round_id: mockBettingRoundId }], error: null });
      // Mock betting_rounds lookup to fail
      mockSingleRound.mockResolvedValue({ data: null, error: roundDbError });

      // Act
      await POST(request);

      // Assert
      expect(mockSupabaseGetUser).toHaveBeenCalledTimes(1);
      // Check validation calls were made
      expect(mockFrom).toHaveBeenCalledWith('betting_round_fixtures');
      expect(mockFrom).toHaveBeenCalledWith('betting_rounds');
      expect(mockSelectRound).toHaveBeenCalledWith('status, earliest_fixture_kickoff');
      expect(mockEqRound).toHaveBeenCalledWith('id', mockBettingRoundId); // Use consistent ID
      expect(mockSingleRound).toHaveBeenCalledTimes(1);
      // Ensure upsert was NOT called
      expect(mockSupabaseUpsert).not.toHaveBeenCalled(); 
      // Check TOTAL calls to mockFrom (round_fixtures + rounds)
      expect(mockFrom).toHaveBeenCalledTimes(2);
      // Check final response
      expect(mockNextResponseJson).toHaveBeenCalledTimes(1);
      expect(mockNextResponseJson).toHaveBeenCalledWith({ error: 'Internal server error: Could not verify betting round details.' }, { status: 500 });
  });

}); 